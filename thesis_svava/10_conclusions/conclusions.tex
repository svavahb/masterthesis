\chapter{Conclusions}
Among the four communication technologies discussed in this thesis, GraphQL, gRPC and RSocket all seem to be a better fit for microservice architecture than REST. For inter-service communication, REST lacks many of the features that give the other three increased performance, such as multiplexing, header compression, more efficient encoding or flexible client-defined queries. The experimental results showcase this, attested by the fact that REST never had the best performance out of the four in any test case. REST suffers from the fact that it is a style developed long before microservice architecture was popularized. It is designed for HTTP communications focusing on hypermedia intended for display in browsers. Within the microservices world, REST is most appropriate for client-facing APIs but even then, the issues of under- and over-fetching can cause worse performance as well as lead developers to rely on ill-designed workarounds that break the constraints of REST. However, since REST has been so popular since its inception, most web and back-end developers are very familiar with it. For simpler systems with simpler use cases, REST still serves its purpose.

For similar reasons, GraphQL is also better suited for client-facing APIs than for inter-service communications. It has several advantages over REST, mainly due to its strongly typed schema and client-defined queries. A single GraphQL request can have the same performance as a single REST request but the ability to easily query for multiple resources with a single request without having to define a specific method/endpoint for it gives GraphQL a considerable edge not just on REST, but also on gRPC and RSocket as was shown in figure \ref{fig:stagger_2b}. For microservices systems with complex underlying data models (especially ones structured as graphs) and/or serving multiple clients with different needs, GraphQL is a good choice.

In contrast, gRPC and RSocket are better suited for inter-service communications than both REST and GraphQL, each being designed explicitly for microservices communications. The two show very similar performance results, with the same result in the first test case, gRPC being slightly faster in the second and RSocket slightly faster in the other three. For both, the impact of a high number of simultaneous requests over a single connection decreased the performance, indicating that spreading the requests over multiple connections could improve the overall performance. However, RSocket allows much more control over this than gRPC, with implementations of gRPC implicitly reusing the connection within the same process even when the developer explicitly attempts to open a separate one. Both technologies offer multiple interaction models, multiplexing and reduced bandwidth either through header compression or binary encoding. RSocket however has an advantage over gRPC in not adhering to the client-server model, allowing communicating services to act more like peers. Finally, the default usage of protocol buffers in gRPC can put it either at an advantage or disadvantage, depending on the requirements of the system at hand. The strong typing offered can be safer and provides better understanding between different teams of the interface behavior and the code generation can save time in development, however it limits flexibility and freedom over what can be sent over the network. gRPC is also tied to HTTP/2, while RSocket can use any byte stream protocol, even different ones in the same service.

Ultimately, the choice of a technology not only depends on the architecture chosen for a system, but also the experience and preference of the developers, the specifics of the use case, complexity of the system and data model, and the performance requirements. It would be near impossible to design one protocol or framework which is perfect for microservices in every way. However, it should always be possible, through careful analysis, to find the approach that works the best for the case at hand. For Picnic's use case, the author's recommendation would be GraphQL for client-facing APIs due to its better performance and flexible querying, and RSocket for inter-service communications due to the freedom and control it provides.