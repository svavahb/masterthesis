\chapter{Suitability for microservices}\label{sec:suitability}
In this chapter, the first research question will be answered, assessing the suitability of each of the four technologies for microservices based on the analysis in chapter \ref{sec:comparison}.

\section{REST}
REST has been the main choice for web services for several years now, and not without reason. It was designed for HyperText-driven applications \cite{fielding2017reflections} and performs very well for that purpose. However, it was not designed with complex service-to-service communications in mind, where the services typically don't even deal in hypermedia at all. Hypertext and hypermedia are designed to be read and consumed by humans, but in a service-to-service case, no humans are involved on either end. The data is sent from a machine, and received by a machine, and neither end cares that the payload can be interpreted by a human if intercepted along the way. In addition, the first constraint of REST contradicts its usage for inter-service communication, as both actors in the data exchange are in charge of their own data storage. As is often the case, a tool designed for the job at hand usually suits better than a tool designed for a different purpose. REST could however serve well for the client-facing API of a microservices system, for the data which is intended to be consumed by humans. In a system with a simpler data model, where use cases require fewer resources, REST is a good choice as it is familiar to most developers and simple and easy to learn for new developers. For a more complex system where performance is paramount however, there are better options.

\section{GraphQL}
GraphQL was also not designed for microservices and instead intended to support native client applications \cite{schrock2015blog}. As such, it is highly suitable for client-facing APIs in a microservices-based system, potentially more so than REST in more complex systems. The advantages of GraphQL over REST regarding the issues of over- and under-fetching have already been discussed in the previous chapter. The issue of under-fetching is even more relevant for microservice architecture specifically. Resource types can often originate from different microservices, which means that when a client only requests a subset of the resources possible in a query type, fewer microservices will be involved in the transaction. This is not communicated to the client and in fact, the schema and single endpoint can essentially abstract away from the client that the system is composed of multiple services, making the whole system appear as one whole. The architectural pattern \textit{API Gateway} has been used by some to achieve this same goal, by routing all requests through a single gateway with a single interface. In Taibi's study of microservices architectural patterns two of the downsides mentioned for the API Gateway pattern are:
\begin{itemize}
    \item \textit{Implementation complexity}: Due to the implementation of several interfaces for each service.
    \item \textit{API reuse issues}: Clients that use the same interface all need to be updated when the interface is changed \cite{taibi2018architectural}.
\end{itemize}
GraphQL helps address these with the unified schema and client-defined queries, mitigating the issues of the API gateway pattern. Another pattern mentioned in the same study is the \textit{service discovery} pattern, where DNS addresses of services are dynamically resolved through the use of a service registry. The schema of GraphQL can also support this pattern by keeping the interface stable even when a service is changed, to minimize the impact on other services that communicate with it.

\section{gRPC}
gRPC on the other hand was designed explicitly for microservices and its features support the architecture's requirements, especially between services as it is used within the Google microservice ecosystem \cite{ryan2015motivation}. The multiplexing, flow control and possibilities of both asynchronous and synchronous calls can offer performance and efficiency benefits, as discussed in section \ref{sec:transfer}. Each gRPC service exposes a strongly typed interface through its protocol, providing many of the same advantages as GraphQL offers with its schema, although it does not feature client-defined queries. gRPC, as an RPC framework can be simpler in development than others, due to the fact that methods are designed and used in the same way as local methods, with the specifics of how those methods get translated to network requests hidden from the developers. In addition, the usage of protocol buffers can minimize the amount of time spent developing, since the boilerplate code\footnote{Such as constructors, builders, getter and setter methods} for each message type is automatically generated. However, the code generation is limited by the libraries and plugins available for each platform. Plenty of libraries exist that generate boilerplate code, unrelated to protocol buffers, and if the developers have a preference for those it can limit the usefulness of protocol buffers since objects now need to be converted between the different types.

\section{RSocket}
RSocket was also designed for microservices and offers features such as multiplexing, flow control and asynchronous communication. What sets RSocket apart from the other three is the non-adherence to the classic client-server model. For a microservices system, the client-server model makes little sense as the services behave more like peers, and should be able to freely communicate with each other no matter which service initiated the interaction (in contrast, gRPC's bidirectional streaming mode can only be initiated by the client). In addition, RSocket does not rely on HTTP, and allows for a lot of freedom in how connections are managed between the services, and in how the interface is designed. With this added freedom though comes a certain complexity in development, since developers need to evaluate their options and make design decisions that may be sub par and could negatively affect the performance or efficiency of the final product.