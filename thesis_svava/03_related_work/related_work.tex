\chapter{Related work}\label{sec:related}
In this chapter, literature and papers related to this paper's subject will be reviewed. First, literature relating to microservices, their performance and choice of communication technology will be documented. Next, papers that aim to compare any of the four communication technologies (REST, GraphQL, RSocket and gRPC) or related technologies will be covered, first in general and then specifically in the context of microservices.

\section{Microservices performance}
As mentioned earlier, the interest in microservices has exploded in the last few years. In a Google Scholar search initiated at the time of writing this paper, around 17,500 results are returned when searching for papers containing the word \textit{microservices} in the title. However, few of them are focused explicitly on both communication and performance. As mentioned in chapter \ref{sec:intro}, the three papers by Ghofrani, Viggiato and Zimmerman (respectively) all serve as overviews of the state of practice and research into microservices \cite{ghofrani2018challenges} \cite{viggiato2018microservices} \cite{zimmermann2016microservices}. Ghofrani and Viggiato both found that performance of remote communications in microservices were rated as important challenges by professionals, while Zimmermann questioned the status of RESTful HTTP as the de facto communication technology of microservices. In Soldani's 2018 review of grey literature identifying pains and gains of microservices, API versioning, communication heterogeneity and service contracts are identified as pains, which are all highly relevant to the choice of communication technology for microservices \cite{soldani2018pains}. Finally, in the 2017 article \textit{Processes, Motivations, and Issues for Migrating to Microservices Architectures} by Taibi, Lenarduzzi and Pahl \cite{taibi2018architectural}, communication among services is named as a drawback to the microservices architecture as it adds complexity to the implementation as well as causing possible latency issues, both of which could potentially be addressed by using a communication technology better suited to the architecture.

A number of studies were found that analyzed the performance of microservices, but these were more focused on either comparing microservices to other architectures, or investigating the effects of the infrastructure on the performance. Ueda, Nakaike and Ohara fall into the first camp. They analyzed the performance of microservice-based systems in their 2016 report \textit{Workload Characterization for Microservices} \cite{ueda2016workload}. Their goal was to compare microservices to monolithic applications, however they did show that the microservice-based application spent more time in communication libraries than the monolithic one, indicating that improving the communication performance of microservices could minimize the gap in performance between microservices-based architectures and monolithic ones. Similarly, Gan and Delimitrou showed that in a microservice-based system, communication is a more significant bottleneck than computation when compared with the same application written as a monolith \cite{gan2018architectural}. On the other hand, Amaral et al. \cite{amaral2015performance} and Kratzke \cite{kratzke2017microservices} each performed research on the performance of microservices, but both focused on the impact of containers (e.g. Docker) and the underlying infrastructure used to deploy the services, rather than the design or architecture of the microservices themselves.

\section{Communication technologies in web services}
A number of papers have been published which compared GraphQL to REST APIs in terms of either architecture or performance, but not specifically for microservices. Eizinger's 2017 master thesis compared REST and GraphQL in terms of API design, finding that using GraphQL shifts responsibilities from the client to the server \cite{eizinger2017api}. Vogel et al. conducted experiments on the same server, one before migrating fro mREST to GraphQL and one after and found that for a single request the performance was similar. However, for cases where multiple resources were required, GraphQL was faster due to a reduction in the number of requests needed \cite{vogel2017experiences}. Similarly, VÃ¡zquez-Ingelmo et al. migrated a system from REST to GraphQL and observed a decrease in average response time due to a reduction of request volume \cite{vazquez2017improving}. Finally, Cederlund performed experiments on the same system developed with either REST or GraphQL, and showed similar results as Vogel et al. with a similar performance in single-resource test cases but increased performance by GraphQL in multiple-resource test cases \cite{cederlund2016performance}.

However, as far as the author knows, few research-based literature has been published comparing either REST or GraphQL to gRPC and RSocket. Chamas, Cordeiro and Eler analyzed the energy cost differences of REST, SOAP, Socket and gRPC, however they did not consider the performance (e.g. speed) of the technologies \cite{chamas2017comparing}. Multiple papers have been written that seek to compare and contrast REST with RPC frameworks in general, however these are less relevant since even though gRPC is an RPC-based framework, the papers focus mostly on SOAP or other synchronous RPC approaches (while gRPC can be both synchronous and asynchronous) \cite{mironela2009importance,feng2009rest,aboutgrpc,vinoski2008rpc,kennedy2009framework}. Similarly, Socket communications have been compared with REST \cite{choi2012performance,cho2014replacing}, however RSocket offers functionalities beyond plain socket communications which these comparisons do not take into account.

\section{Communication technologies in microservices}
For analysis of architecture or performance of communications specifically in microservices, a limited number of papers exist. Hong, Yang and Kim conducted a performance analysis of RESTful APIs versus RabbitMQ for microservices, finding that RabbitMQ (a message broker and queueing server \cite{rostanski2014evaluation}) performed better than REST, with more stability in situations of load \cite{hong2018performance}. However, this thesis focuses more on comparing frameworks and protocols that are centered around direct message transport rather than queueing systems. For this reason, RabbitMQ was not included in the evaluation. 

Nguyen performed experiments to compare the performance of three RPC-based frameworks in microservices architecture in her 2016 thesis, concluding that even though gRPC did not have the best performance in all cases, it is a good choice for a microservices architecture based on other advantages, such as extensive documentation, active development and a "modern style" \cite{nguyen2016benchmarking}.

The paper most directly related to this thesis (and the original inspiration for it) is the 2017 master's thesis \textit{Efficient Communication With Microservices} by Johansson \cite{johansson2017efficient}. Johansson compared the performance of REST over HTTP with JSON with GraphQL and found that GraphQL was slower in all cases. However, there were issues with his methodology and experiment design. None of his test cases showcased the most prominent benefit of GraphQL: that fewer requests are needed to fetch the same data. Thus, his conclusion that GraphQL has a worse performance than REST is incomplete. In addition, he included a small section on gRPC and Apache Thrift, but did not provide arguments supporting his decision to not include those in the performance comparison.